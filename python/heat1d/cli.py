# -*- coding: utf-8 -*-

"""Command-line interface for heat1d."""

import os
import sys
from pathlib import Path

import click
import numpy as np


def _resolve_planet(name, overrides):
    """Load a planet from the ``planets`` package, applying any overrides.

    Parameters
    ----------
    name : str
        Planet name (e.g., "Moon", "Mercury").
    overrides : dict
        Key-value pairs to override on the planet object.

    Returns
    -------
    planet : object
        Planet object (possibly modified).
    """
    import planets as planets_pkg

    planet = getattr(planets_pkg, name, None)
    if planet is None:
        raise click.ClickException(
            f"Unknown planet '{name}'. Available: "
            + ", ".join(
                a for a in dir(planets_pkg)
                if not a.startswith("_") and hasattr(getattr(planets_pkg, a), "day")
            )
        )
    for key, val in overrides.items():
        if hasattr(planet, key):
            setattr(planet, key, val)
        else:
            raise click.ClickException(
                f"Planet '{name}' has no attribute '{key}'"
            )
    return planet


@click.command(context_settings={"help_option_names": ["-h", "--help"]})
@click.argument("config_file", required=False, type=click.Path(exists=True))
@click.option("--lat", type=float, default=None, help="Latitude [degrees].")
@click.option("--ndays", type=int, default=None, help="Number of output days.")
@click.option(
    "--solver",
    type=click.Choice(["explicit", "crank-nicolson", "implicit", "fourier-matrix"], case_sensitive=False),
    default=None,
    help="Solver scheme.",
)
@click.option("--planet", "planet_name", type=str, default=None, help="Planet name (e.g. Moon).")
@click.option("--chi", type=float, default=None, help="Radiative conductivity parameter.")
@click.option("--albedo", type=float, default=None, help="Surface albedo.")
@click.option("--output-dir", type=click.Path(), default=None, help="Output directory.")
@click.option("--prefix", type=str, default=None, help="Output filename prefix.")
@click.option("--no-plot", is_flag=True, help="Suppress plot generation.")
@click.option("--validate", is_flag=True, help="Run Moon validation suite.")
@click.option("--quiet", is_flag=True, help="Suppress progress output.")
@click.option(
    "--backend",
    type=click.Choice(["python", "c"], case_sensitive=False),
    default="python",
    help="Backend engine (default: python).",
)
@click.option("--accuracy", type=float, default=1.0,
              help="Temperature accuracy [K] for adaptive timestepping (implicit/CN). Default: 1.")
@click.option("--no-adaptive", "no_adaptive", is_flag=True,
              help="Disable adaptive timestepping (use fixed step size).")
@click.option("--output-dt", "output_dt", type=float, default=0.5,
              help="Output time step [local hours, 0-24 scale]. Default: 0.5.")
@click.option("--validate-c", "validate_c", is_flag=True, help="Run C validation tests.")
@click.option("--compare", is_flag=True, help="Compare C vs Python backends.")
@click.option("--flux-file", type=click.Path(exists=True), default=None,
              help="External flux file (generated by generate-flux).")
@click.option("--use-spice", is_flag=True,
              help="Use JPL Horizons ephemeris for illumination (requires network).")
@click.option("--lon", type=float, default=0.0,
              help="Longitude [degrees east]. Used with --use-spice. Default: 0.")
@click.option("--start-time", "start_time", type=str, default=None,
              help="UTC start time, e.g. '2024-06-01 12:00'. Required with --use-spice.")
@click.option("--stop-time", "stop_time", type=str, default=None,
              help="UTC stop time. Alternative to --ndays with --use-spice.")
@click.option("--body-id", "body_id", type=str, default=None,
              help="Horizons body ID override (e.g. '301' for Moon, '2101955' for Bennu).")
@click.option("--no-eclipses", is_flag=True,
              help="Disable automatic eclipse detection for satellites.")
@click.option("--parent-body-id", "parent_body_id", type=str, default=None,
              help="Horizons ID of parent body for eclipse detection (e.g. '399' for Earth).")
@click.option("--psr-d-D", "psr_d_D", type=float, default=None,
              help="PSR crater depth/diameter ratio (e.g. 0.2). Enables bowl-shaped crater PSR mode.")
def main(
    config_file,
    lat,
    ndays,
    solver,
    planet_name,
    chi,
    albedo,
    output_dir,
    prefix,
    no_plot,
    validate,
    quiet,
    backend,
    accuracy,
    no_adaptive,
    output_dt,
    validate_c,
    compare,
    flux_file,
    use_spice,
    lon,
    start_time,
    stop_time,
    body_id,
    no_eclipses,
    parent_body_id,
    psr_d_D,
):
    """Run the heat1d 1-D thermal model.

    Optionally accepts a YAML configuration file. Command-line options
    override values from the file.

    \b
    Examples:
        heat1d                              # Moon equator, defaults
        heat1d --lat 45 --solver implicit   # Moon 45N, implicit solver
        heat1d moon.yaml --lat 30           # YAML config, override lat
        heat1d --validate                   # Run validation suite
        heat1d --backend c --lat 0          # Run C backend at equator
        heat1d --validate-c                 # Run C validation tests
        heat1d --compare --solver explicit  # Compare C vs Python
        heat1d --use-spice --lat 0 --lon 0 --start-time "2024-06-15 12:00" --ndays 1
    """
    from .config import Configurator
    from .model import Model

    # --- Validation mode ---
    if validate:
        _run_validation(output_dir, quiet, solver=solver)
        return

    # --- C validation mode ---
    if validate_c:
        _run_c_validation(quiet, no_plot=no_plot, output_dir=output_dir)
        return

    # --- Compare mode ---
    if compare:
        _run_compare(lat, solver, albedo, quiet)
        return

    # --- Build configuration ---
    yaml_data = {}
    if config_file is not None:
        config, yaml_data = Configurator.from_yaml(config_file)
    else:
        config = Configurator()

    # CLI overrides on Configurator fields
    if solver is not None:
        config.solver = solver
    if chi is not None:
        config.chi = chi
    if no_adaptive:
        config.adaptive_tol = None
    else:
        config.adaptive_tol = accuracy
    # Note: output_dt conversion to output_interval happens after planet
    # is resolved (requires planet.day).
    # Re-validate after overrides
    config.__post_init__()

    # --- Resolve run parameters ---
    run_lat = lat
    if run_lat is None:
        run_lat = yaml_data.get("latitude", 0.0)

    run_ndays = ndays
    if run_ndays is None:
        run_ndays = yaml_data.get("ndays", 1)

    run_planet_name = planet_name
    if run_planet_name is None:
        planet_cfg = yaml_data.get("planet", {})
        run_planet_name = planet_cfg.get("name", "Moon") if isinstance(planet_cfg, dict) else "Moon"

    out_cfg = yaml_data.get("output", {})
    run_output_dir = output_dir if output_dir is not None else out_cfg.get("directory", "output")
    run_prefix = prefix if prefix is not None else out_cfg.get("prefix", "heat1d")

    # --- Resolve planet with overrides ---
    planet_overrides = {}
    planet_cfg = yaml_data.get("planet", {})
    if isinstance(planet_cfg, dict):
        # Copy overridable planet properties from YAML
        for key in ("albedo", "emissivity", "ks", "kd", "rhos", "rhod", "H", "cp0", "Qb"):
            if key in planet_cfg:
                planet_overrides[key] = planet_cfg[key]
    # CLI albedo override takes precedence
    if albedo is not None:
        planet_overrides["albedo"] = albedo

    planet = _resolve_planet(run_planet_name, planet_overrides)

    # Convert --output-dt (local hours) to output_interval (seconds)
    if output_dt is not None and output_dt > 0:
        config.output_interval = planet.day * output_dt / 24.0

    # --- Horizons / SPICE integration (if requested) ---
    # Read YAML horizons section as defaults (CLI flags override)
    horizons_cfg = yaml_data.get("horizons", {})
    if horizons_cfg.get("enabled", False) and not use_spice:
        use_spice = True
    if use_spice:
        if lon == 0.0 and "lon" in horizons_cfg:
            lon = horizons_cfg["lon"]
        if start_time is None:
            start_time = horizons_cfg.get("start_time")
        if stop_time is None:
            stop_time = horizons_cfg.get("stop_time")
        if body_id is None:
            body_id = horizons_cfg.get("body_id")
        # Eclipse options from YAML
        eclipses_cfg = horizons_cfg.get("eclipses", {})
        if parent_body_id is None:
            parent_body_id = eclipses_cfg.get("parent_body_id")
        if not no_eclipses and eclipses_cfg.get("enabled") is False:
            no_eclipses = True

    flux_series = None
    flux_dt = None

    if use_spice:
        from datetime import datetime, timedelta
        from .horizons import fetch_solar_flux, HorizonsError

        if start_time is None:
            raise click.ClickException("--start-time is required with --use-spice")

        # Determine stop time
        if stop_time is None:
            t0 = datetime.strptime(start_time, "%Y-%m-%d %H:%M")
            ndays_earth = run_ndays * planet.day / 86400.0
            t1 = t0 + timedelta(days=ndays_earth)
            computed_stop = t1.strftime("%Y-%m-%d %H:%M")
        else:
            computed_stop = stop_time
            # Compute ndays from time range
            t0 = datetime.strptime(start_time, "%Y-%m-%d %H:%M")
            t1 = datetime.strptime(stop_time, "%Y-%m-%d %H:%M")
            total_s = (t1 - t0).total_seconds()
            run_ndays = total_s / planet.day

        try:
            flux_series, flux_dt, spice_meta = fetch_solar_flux(
                planet_name=run_planet_name,
                lon_deg=lon,
                lat_deg=run_lat,
                start_time=start_time,
                stop_time=computed_stop,
                body_id=body_id,
                output_interval_s=config.output_interval,
                planet_day_s=planet.day,
                planet=planet,
                eclipses=not no_eclipses,
                parent_body_id=parent_body_id,
            )
        except HorizonsError as exc:
            raise click.ClickException(f"Horizons query failed: {exc}")

        if not quiet:
            click.echo(f"  Horizons: body={spice_meta['body_id']}, "
                       f"{spice_meta['n_samples']} samples, dt={flux_dt:.0f} s")
            click.echo(f"  UTC:      {start_time} â†’ {computed_stop}")
            einfo = spice_meta.get("eclipse_info")
            if einfo and einfo["n_eclipses"] > 0:
                click.echo(f"  Eclipses: {einfo['n_eclipses']} detected, "
                           f"max obscuration {einfo['max_fraction']*100:.1f}%")
            elif einfo is not None:
                click.echo(f"  Eclipses: none detected")

    # --- Print summary ---
    if not quiet:
        click.echo(f"heat1d v0.4.0")
        click.echo(f"  Planet:   {run_planet_name}")
        click.echo(f"  Latitude: {run_lat} deg")
        click.echo(f"  Days:     {run_ndays}")
        click.echo(f"  Solver:   {config.solver}")
        if config.adaptive_tol is not None and config.solver in ("implicit", "crank-nicolson"):
            click.echo(f"  Accuracy: {config.adaptive_tol} K (adaptive)")
        if config.output_interval is not None:
            dt_hr = config.output_interval / planet.day * 24.0
            click.echo(f"  Output:   every {dt_hr:.2g} hr ({config.output_interval:.0f} s)")
        click.echo(f"  Chi:      {config.chi}")
        if psr_d_D is not None:
            click.echo(f"  PSR:      d/D={psr_d_D:.2f} (bowl-shaped crater)")
        if config_file:
            click.echo(f"  Config:   {config_file}")

    # --- Load external flux file (if given, and SPICE not already active) ---
    if flux_file is not None and flux_series is None:
        from .flux import read_flux_file
        flux_series, flux_dt = read_flux_file(flux_file)
        if not quiet:
            click.echo(f"  Flux file: {flux_file} ({len(flux_series)} samples, dt={flux_dt:.2f} s)")
        # Warn if output cadence is too coarse to resolve flux file features
        if config.output_interval is not None:
            output_dt_s = config.output_interval
            if output_dt_s > 10 * flux_dt:
                click.echo(
                    f"  WARNING: output dt ({output_dt_s:.0f} s) is {output_dt_s/flux_dt:.0f}x "
                    f"coarser than flux file dt ({flux_dt:.0f} s).\n"
                    f"           Short events (eclipses) may not appear in output.\n"
                    f"           Consider --output-dt {flux_dt / planet.day * 24.0:.4f} "
                    f"or smaller.",
                    err=True,
                )

    # --- Run model ---
    lat_rad = np.deg2rad(run_lat)

    if backend == "c":
        from .c_wrapper import CModel

        run_solver = solver if solver is not None else config.solver
        # Translate seconds-based params to integer nperday for C backend
        if config.output_interval is not None:
            c_nperday = int(round(planet.day / config.output_interval))
        else:
            c_nperday = 480
        if config.equil_dt is not None:
            c_equil_nperday = int(round(planet.day / config.equil_dt))
        else:
            c_equil_nperday = 480
        c_adaptive = config.adaptive_tol if config.adaptive_tol is not None else 0.0
        c_h = getattr(planet, "H", 0.06)
        model = CModel(
            planet=planet, lat=lat_rad, ndays=run_ndays,
            solver=run_solver, ti=55.0, h=c_h,
            equil_nperday=c_equil_nperday,
            nperday_output=c_nperday,
            adaptive_tol=c_adaptive,
            flux_series=flux_series, flux_dt=flux_dt,
        )
    else:
        lon_rad = np.deg2rad(lon)
        model = Model(planet=planet, lat=lat_rad, lon=lon_rad, ndays=run_ndays,
                      config=config, flux_series=flux_series, flux_dt=flux_dt,
                      psr_d_D=psr_d_D)

    if not quiet:
        click.echo(f"Running model (backend={backend})...")
    model.run()
    if not quiet:
        click.echo("Done.")

    # --- Save output ---
    outdir = Path(run_output_dir)
    outdir.mkdir(parents=True, exist_ok=True)

    # Save temperature data
    temp_file = outdir / f"{run_prefix}_temperature.csv"
    header = "local_time_hr," + ",".join(f"z={z:.4f}m" for z in model.profile.z)
    data = np.column_stack([model.lt, model.T])
    np.savetxt(temp_file, data, delimiter=",", header=header, comments="")
    if not quiet:
        click.echo(f"  Temperature data: {temp_file}")

    # Save depth grid (Python backend has rho/kc; C backend only has z)
    if hasattr(model.profile, "rho"):
        grid_file = outdir / f"{run_prefix}_grid.csv"
        grid_header = "depth_m,density_kg_m3,kc_W_m_K"
        grid_data = np.column_stack([model.profile.z, model.profile.rho, model.profile.kc])
        np.savetxt(grid_file, grid_data, delimiter=",", header=grid_header, comments="")
        if not quiet:
            click.echo(f"  Grid data:        {grid_file}")

    # Summary statistics
    if not quiet:
        click.echo(f"\n  T_max  = {model.T[:, 0].max():.2f} K")
        click.echo(f"  T_min  = {model.T[:, 0].min():.2f} K")
        click.echo(f"  T_mean = {model.T[:, 0].mean():.2f} K")

    # --- Optional plot ---
    if not no_plot:
        try:
            from . import plotting

            fig_file = outdir / f"{run_prefix}_plot.png"
            plotting.plot_profile_and_diurnals(model)
            import matplotlib.pyplot as plt

            plt.savefig(fig_file, dpi=150, bbox_inches="tight")
            plt.close()
            if not quiet:
                click.echo(f"  Plot saved:       {fig_file}")
        except Exception as e:
            if not quiet:
                click.echo(f"  Warning: could not generate plot: {e}", err=True)


def _run_validation(output_dir, quiet, solver=None):
    """Run the Moon validation suite.

    Parameters
    ----------
    solver : str or None
        If given, run only this solver.  If None, run all four solvers.
    """
    try:
        from .validation import run_validation_suite
    except ImportError:
        raise click.ClickException(
            "Validation module not found. Make sure heat1d.validation is available."
        )

    out = output_dir if output_dir is not None else "output/validation"
    if not quiet:
        click.echo("Running Moon validation suite...")
    run_validation_suite(solvers=solver, output_dir=out, quiet=quiet)
    if not quiet:
        click.echo(f"Validation complete. Results saved to: {out}")


def _run_c_validation(quiet, no_plot=False, output_dir=None):
    """Run the C validation test suite with plots."""
    try:
        from .c_wrapper import run_c_validation_suite
    except ImportError:
        raise click.ClickException(
            "C wrapper module not found. Make sure heat1d.c_wrapper is available."
        )

    out = output_dir if output_dir is not None else "output/c_validation"
    if not quiet:
        click.echo("Running C validation suite...")
    run_c_validation_suite(output_dir=out, quiet=quiet, no_plot=no_plot)


def _run_compare(lat, solver, albedo, quiet):
    """Compare C vs Python backends."""
    try:
        from .c_wrapper import compare_c_python
    except ImportError:
        raise click.ClickException(
            "C wrapper module not found. Make sure heat1d.c_wrapper is available."
        )

    run_lat = lat if lat is not None else 0.0
    run_solver = solver if solver is not None else "explicit"
    run_albedo = albedo if albedo is not None else 0.12

    if not quiet:
        click.echo(f"Comparing C vs Python (lat={run_lat}, solver={run_solver}, "
                    f"albedo={run_albedo})...")
    compare_c_python(
        lat_deg=run_lat, solver=run_solver, albedo=run_albedo, quiet=quiet,
    )


if __name__ == "__main__":
    main()
